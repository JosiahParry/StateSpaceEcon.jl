var documenterSearchIndex = {"docs":
[{"location":"#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"Pages = [\"index.md\"]","category":"page"},{"location":"#Steady-state-solver","page":"Reference","title":"Steady state solver","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"Modules = [StateSpaceEcon.SteadyStateSolver]\nPrivate = false","category":"page"},{"location":"#StateSpaceEcon.SteadyStateSolver","page":"Reference","title":"StateSpaceEcon.SteadyStateSolver","text":"SteadyStateSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for finding a steady state of a model.\n\n\n\n\n\n","category":"module"},{"location":"#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{ModelBaseEcon.Model}","page":"Reference","title":"StateSpaceEcon.SteadyStateSolver.check_sstate","text":"check_sstate(model; <options>)\n\nRun a diagnostic test to determine if the steady state solution stored within the given model object is indeed a solution of the steady state system of equations.\n\nReturn the number of steady state equations that are violated by the current steady state solution. If verbose=true, also display diagnostic information in the form of listing all bad equations and their residuals.\n\nOptions\n\nStandard options (default values from model.options)\n\nverbose \ntol - an equation is considered satisfied if its residual, in absolute value, is smaller than this number.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{ModelBaseEcon.Model}","page":"Reference","title":"StateSpaceEcon.SteadyStateSolver.clear_sstate!","text":"clear_sstate!(model; lvl=0.1, slp=0.0, <options>)\n\nSet the steady state values to the provided defaults and presolve.\n\nArguments\n\nmodel - the model instance\nlvl, slp - the initial guess for the level and the slope. Each could be a number or a vector of length equal to the number of variable in the mode.\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{ModelBaseEcon.Model}","page":"Reference","title":"StateSpaceEcon.SteadyStateSolver.diagnose_sstate","text":"diagnose_sstate([point,] model)\n\nRun diagnostics on the steady state of the given model. If point is not given, then we check the steady state solution stored inside the given model.\n\nReturn a tuple of \"bad\" equations and \"bad\" variables. \n\nThe set of \"bad\" equations is one that is inconsistent, i.e. there is no solution. This might happen if the system is overdetermined.\n\nThe set of \"bad\" variables contains variables that cannot be solved uniquely. This might happen if the system is underdetermined. In this case, try adding steady state constraints until you get a unique solution. See @steadystate in ModelBaseEcon.\n\nwarning: Internal function\nThe output from this function may be difficult to read.<br> Call check_sstate instead.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{ModelBaseEcon.Model,AbstractArray{Float64,1}}","page":"Reference","title":"StateSpaceEcon.SteadyStateSolver.initial_sstate!","text":"initial_sstate!(model, init; <options>)\n\nSet the steady state values from the given vector and presolve.\n\nCall this function to specify initial guesses for the iterative steady state solver. If the value of a steady state variable is known, it is better to use @steadystate to add that as a steady state constraint.\n\nArguments\n\nmodel - the model.\ninit - a vector of length equal to twice the number of variables in the model. The level and slope values are staggered, i.e., the level and slope of variable j are in init[2j-1] and init[2j].\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{ModelBaseEcon.Model}","page":"Reference","title":"StateSpaceEcon.SteadyStateSolver.sssolve!","text":"sssolve!(model; <options>)\n\nSolve the steady state problem for the given model.\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\ntol, maxiter - control the stopping criteria of the solver\n\nSpecific options\n\npresolve::Bool - whether or not to use a presolve pass. Default is true.\nmethod::Symbol - choose the solution algorithm. Valid options are :nr for Newton-Raphson, :lm for Levenberg-Marquardt, and :auto. The :auto method starts with the LM algorithm and automatically switches to NR when it starts to converge. Default is :nr.\n\n\n\n\n\n","category":"method"},{"location":"#Plans","page":"Reference","title":"Plans","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"Modules = [StateSpaceEcon.Plans]\nPrivate = false","category":"page"},{"location":"#StateSpaceEcon.Plans","page":"Reference","title":"StateSpaceEcon.Plans","text":"Plans\n\nModule part of StateSpaceEcon. This module implements the Plan data structure, which is used in simulations. The plan object contains information about the range of the simulation and which variables and shocks are exogenous or endogenous at each period of the range.\n\nConstructors\n\nPlan(model, range)\n\nModify the plan\n\nexogenize!, endogenize! - make variables exogenous or endogenous\nexog_endo!, endo_exog! - swap exogenous and endogenous variables\nautoexogenize! - exogenize and endogenize variables according to the list in the model\n\nPrepare data for simulation\n\nzeroarray, zerodict, zerodata - prepare a matrix or a dictionary or a SimData of data for the simulation containing zeros.\nsteadystatearray, steadystatedict, steadystatedata - prepare a matrix or a dictionary or a SimData of data for the simulation containing the steady state.\n\n\n\n\n\n","category":"module"},{"location":"#StateSpaceEcon.Plans.Plan","page":"Reference","title":"StateSpaceEcon.Plans.Plan","text":"Plan{T <: MIT}\n\nA data structure representing the simulation plan. It holds information about the time range of the simulation and which variables/shocks are exogenous at each period.\n\n\n\n\n\n","category":"type"},{"location":"#StateSpaceEcon.Plans.Plan-Tuple{ModelBaseEcon.Model,AbstractUnitRange}","page":"Reference","title":"StateSpaceEcon.Plans.Plan","text":"Plan(model, range)\n\nCreate a default simulation plan for the given model over the given range. The range of the plan is augmented to include periods before and after the given range, over which initial and final conditions will be applied. \n\nInstead of a range, one could also pass in a single moment in time (MIT) instance, in which case it is interpreted as a range of length 1.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan,ModelBaseEcon.Model,Any}","page":"Reference","title":"StateSpaceEcon.Plans.autoexogenize!","text":"autoexogenize!(plan, model, date)\n\nModify the given plan according to the \"autoexogenize\" protocol defined in the given model. All variables in the autoexogenization list become endogenous and their corresponding shocks become exogenous over the given date or range. date can be a moment in time (same frequency as the given plan), a range, an iterable, or a container.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan,Any,Any,Any}","page":"Reference","title":"StateSpaceEcon.Plans.endo_exog!","text":"endo_exog!(plan, endo_vars, exog_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.endogenize!-Tuple{Plan,Symbol,Any}","page":"Reference","title":"StateSpaceEcon.Plans.endogenize!","text":"endogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be endogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan,Any,Any,Any}","page":"Reference","title":"StateSpaceEcon.Plans.exog_endo!","text":"exog_endo!(plan, exog_vars, endo_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.exogenize!-Tuple{Plan,Symbol,Any}","page":"Reference","title":"StateSpaceEcon.Plans.exogenize!","text":"exogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be exogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.plansum-Tuple{ModelBaseEcon.Model,Plan}","page":"Reference","title":"StateSpaceEcon.Plans.plansum","text":"plansum(model, plan)\n\nReturn the total number of exogenous variables in the simulation plan. Periods over which initial and final conditions are imposed are not counted in this sum.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.setexog!-Tuple{Plan,Int64,Any}","page":"Reference","title":"StateSpaceEcon.Plans.setexog!","text":"setexog!(plan, t, vinds)\n\nModify the plan at time t such that vinds are exogenous and the rest are endogenous.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.steadystatearray-Tuple{ModelBaseEcon.Model,AbstractUnitRange}","page":"Reference","title":"StateSpaceEcon.Plans.steadystatearray","text":"steadystatearray(model, plan)\nsteadystatearray(model, range)\n\nCreate a matrix of the proper dimensions for a simulation with the given model with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.steadystatedata-Tuple{ModelBaseEcon.Model,AbstractUnitRange}","page":"Reference","title":"StateSpaceEcon.Plans.steadystatedata","text":"steadystatedata(model, plan)\nsteadystatedata(model, range)\n\nCreate a SimData containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.steadystatedict-Tuple{ModelBaseEcon.Model,AbstractUnitRange}","page":"Reference","title":"StateSpaceEcon.Plans.steadystatedict","text":"steadystatearray(model, plan)\nsteadystatearray(model, range)\n\nCreate a dictionary containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.zeroarray-Tuple{ModelBaseEcon.Model,Plan}","page":"Reference","title":"StateSpaceEcon.Plans.zeroarray","text":"zeroarray(model, plan)\nzeroarray(model, range)\n\nCreate a matrix of the proper dimension for a simulation with the given model with the given plan or over the given range. If a range is given, the data is prepared for the default plan. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.zerodata-Tuple{ModelBaseEcon.Model,Plan}","page":"Reference","title":"StateSpaceEcon.Plans.zerodata","text":"zerodata(model, plan)\nzerodata(model, range)\n\nCreate a NamedTuple containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. If a range is given rather than a plan, the data is prepared for the default plan over that range. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.Plans.zerodict-Tuple{ModelBaseEcon.Model,Plan}","page":"Reference","title":"StateSpaceEcon.Plans.zerodict","text":"zerodict(model, plan)\nzerodict(model, range)\n\nCreate a dictionary containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. If a range is given rather than a plan, the data is prepared for the default plan over that range. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"#Stacked-time-solver","page":"Reference","title":"Stacked time solver","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"Modules = [StateSpaceEcon.StackedTimeSolver]\nPrivate = false","category":"page"},{"location":"#StateSpaceEcon.StackedTimeSolver","page":"Reference","title":"StateSpaceEcon.StackedTimeSolver","text":"StackedTimeSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for solving the dynamic system of equations for the model and running simulations.\n\n\n\n\n\n","category":"module"},{"location":"#StateSpaceEcon.StackedTimeSolver.FCType","page":"Reference","title":"StateSpaceEcon.StackedTimeSolver.FCType","text":"FCType\n\nAn enumeration type representing the possible types of final conditions.\n\nfcgiven - the final conditions are provided by the user.\nfclevel - the final conditions are prescribed from the levels of the steady state solution.\nfcslope - the final conditions are such that the slope of the dynamic solution matches the slope of the steady state solution.\n\n\n\n\n\n","category":"type"},{"location":"#StateSpaceEcon.StackedTimeSolver.array2data-Tuple{AbstractArray{Float64,2},AbstractArray{#s68,1} where #s68<:AbstractString,TimeSeriesEcon.MIT}","page":"Reference","title":"StateSpaceEcon.StackedTimeSolver.array2data","text":"array2data(data, vars, start_date)\n\nConvert the simulation data array to a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.StackedTimeSolver.array2dict-Tuple{AbstractArray{Float64,2},AbstractArray{#s68,1} where #s68<:AbstractString,TimeSeriesEcon.MIT}","page":"Reference","title":"StateSpaceEcon.StackedTimeSolver.array2dict","text":"array2dict(data, vars, start_date)\n\nConvert the simulation data array to a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.StackedTimeSolver.dict2array-Tuple{Dict{#s32,#s31} where #s31 where #s32<:AbstractString,AbstractArray{#s30,1} where #s30<:AbstractString}","page":"Reference","title":"StateSpaceEcon.StackedTimeSolver.dict2array","text":"dict2array(d, vars; range)\n\nConvert a dictionary of TSeries to a 2d array of simulation data for the given range.  The range argument is optional and defaults to nothing.\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.StackedTimeSolver.dictoverlay-Tuple{Dict{String,#s41} where #s41,Dict{String,#s40} where #s40}","page":"Reference","title":"StateSpaceEcon.StackedTimeSolver.dictoverlay","text":"dictoverlay(d1, d2)\n\nMerge two dictionaries. Common key where the values are TSeries of the same frequency are overlayed. Otherwise, a common key takes the value of the last Dict containing it.\n\nSee also: seriesoverlay\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.StackedTimeSolver.seriesoverlay-Tuple{TimeSeriesEcon.TSeries,TimeSeriesEcon.TSeries}","page":"Reference","title":"StateSpaceEcon.StackedTimeSolver.seriesoverlay","text":"seriesoverlay(ts1, ts2)\n\nReturn a new TSeries over the full range of both arguments. The overlapping part contains values from the last argument.\n\nSee also: dictoverlay\n\n\n\n\n\n","category":"method"},{"location":"#StateSpaceEcon.StackedTimeSolver.simulate-Tuple{ModelBaseEcon.Model,Plan,AbstractArray{Float64,2}}","page":"Reference","title":"StateSpaceEcon.StackedTimeSolver.simulate","text":"simulate(model, plan, data; <options>)\n\nRun a simulation for the given model, simulation plan and exogenous data.\n\nArguments\n\nmodel - the Model instance to simulate.\nplan - the Plan for the simulation.\ndata - a 2D Array containing the exogenous data. This includes the initial and final conditions.\n\nOptions as keyword arguments\n\nfctype::FCType - set the desired final condition type for the simulation. The default value is fcgiven. Other possible values include fclevel and fcslope.\ninitial_guess::AbstractMatrix{Float64} - a 2D Array containing the initial guess for the solution. This is used to start the Newton-Raphson algorithm. The default value is an empty array (zeros(0,0)), in which case we use the exogenous data for the initial condition. You can use the steady state solution using steadystatearray.\nlinearize::Bool - set to true to instruct the solver to use the liearized model. If the model is already linearized, this option has the effect that the model gets linearized about the current steady stat and with the value of deviation given here. Otherwise the model is linearized about the steady state. After the simulation is computed, the model is restored to its original state. Default value is false.\ndeviation::Bool - set to true if the data is in deviations from the steady state. This is only relevant if the linearize option is set to true. Default value is false.\nanticipate::Bool - set to false to instruct the solver that all shocks are unanticilated by the agents. Default value is true.\nverbose::Bool - control whether or not to print progress information. Default value is taken from model.options.\ntol::Float64 - set the desired accuracy. Default value is taken from model.options.\nmaxiter::Int - algorithm fails if the desired accuracy is not reached within this maximum number of iterations. Default value is taken from model.options.\n\nSee also:\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#Various","page":"Reference","title":"Various","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"Modules = [StateSpaceEcon]\nPrivate = false","category":"page"},{"location":"#StateSpaceEcon.StateSpaceEcon","page":"Reference","title":"StateSpaceEcon.StateSpaceEcon","text":"StateSpaceEcon\n\nA package for Macroeconomic modelling.\n\n\n\n\n\n","category":"module"},{"location":"#StateSpaceEcon.SimData","page":"Reference","title":"StateSpaceEcon.SimData","text":"SimData\n\nData structure containing the time series data for a simulation.\n\nIt is a collection of TSeries of the same frequency and containing data for the same range. When used for simulation, the range must include the initial conditions, the simulation range and the final conditions, although it could extend beyond that. It must contain time series for all variables and shocks in the model, although it might contain other time series.\n\n\n\n\n\n","category":"type"},{"location":"#StateSpaceEcon.printmatrix-Tuple{Any,Vararg{Any,N} where N}","page":"Reference","title":"StateSpaceEcon.printmatrix","text":"printmatrix(mat [, Val(F), colnames])\n\nDisplay a matrix in full while controlling the formatting of each value and optionally showing the column names.\n\nVal(F) - display each number in the given format F. The format is in the form of a decimal point number where the whole part indicates the total width and the fractional part is the number of digits printed after the decimal point. Default is Val(12.7)\ncolnames - a list of names to display in the first row. The names are displayed as given, possibly with padding to match the width given in the Val argument. If any names are longer than that, they will not be truncated and so the display will not be aligned properly. Sorry about that!\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"","category":"page"}]
}
